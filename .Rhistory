}
cat("\n")
cat("7. LIMPIEZA DE DATOS PROPUESTA\n")
cat("====================================================================\n\n")
# Contar observaciones que se perderÃ­an
invalid_price <- sum(is.na(train$price) | train$price <= 0)
rows_to_remove <- invalid_price
cat("Observaciones a eliminar:\n")
cat(sprintf("  Price invÃ¡lido: %d\n", invalid_price))
cat(sprintf("  TOTAL:          %d (%.2f%%)\n\n",
rows_to_remove,
(rows_to_remove / nrow(train)) * 100))
cat("Observaciones finales:\n")
cat(sprintf("  Original: %s\n", comma(nrow(train))))
cat(sprintf("  DespuÃ©s:  %s\n", comma(nrow(train) - rows_to_remove)))
cat(sprintf("  PÃ©rdida:  %.2f%%\n\n",
(rows_to_remove / nrow(train)) * 100))
# Features a eliminar por >50% NAs
high_na_features <- na_summary$feature[na_summary$na_pct > 50]
if (length(high_na_features) > 0) {
cat("âš ï¸  Features con >50% NAs (considerar eliminar):\n")
for (feat in high_na_features) {
pct <- na_summary$na_pct[na_summary$feature == feat]
cat(sprintf("  â€¢ %s (%.1f%% NAs)\n", feat, pct))
}
cat("\n")
}
cat("====================================================================\n")
cat("RESUMEN Y RECOMENDACIONES\n")
cat("====================================================================\n\n")
# Contar problemas
total_problems <- 0
problem_list <- c()
if (problems_price$nas > 0) {
total_problems <- total_problems + 1
problem_list <- c(problem_list, sprintf("Price tiene %d NAs", problems_price$nas))
}
if (problems_price$zeros > 0) {
total_problems <- total_problems + 1
problem_list <- c(problem_list, sprintf("Price tiene %d ceros", problems_price$zeros))
}
if (problems_price$negatives > 0) {
total_problems <- total_problems + 1
problem_list <- c(problem_list, sprintf("Price tiene %d negativos", problems_price$negatives))
}
if (length(missing_features) > 0) {
total_problems <- total_problems + 1
problem_list <- c(problem_list, sprintf("%d features esperadas no encontradas",
length(missing_features)))
}
if (nrow(na_summary_with_nas) > 0) {
high_na_count <- sum(na_summary_with_nas$na_pct > 10)
if (high_na_count > 0) {
total_problems <- total_problems + 1
problem_list <- c(problem_list, sprintf("%d features con >10%% NAs", high_na_count))
}
}
if (total_problems == 0) {
cat("âœ… DATOS EN PERFECTO ESTADO\n\n")
cat("No se detectaron problemas graves.\n")
cat("Los datos estÃ¡n listos para entrenamiento nocturno.\n\n")
} else {
cat(sprintf("âš ï¸  SE DETECTARON %d PROBLEMAS:\n\n", total_problems))
for (i in 1:length(problem_list)) {
cat(sprintf("%d. %s\n", i, problem_list[i]))
}
cat("\n")
}
cat("RECOMENDACIONES:\n\n")
cat("1. LIMPIEZA DE PRICE:\n")
cat("   train_clean <- train %>% filter(!is.na(price), price > 0)\n\n")
cat("2. FEATURES A USAR:\n")
cat(sprintf("   %d features numÃ©ricas disponibles\n", length(available_features)))
cat("   Sin features categÃ³ricas (texto)\n\n")
cat("3. IMPUTACIÃ“N DE NAs:\n")
cat("   â€¢ Binarias (0/1): Usar 0\n")
cat("   â€¢ Continuas: Usar mediana\n\n")
cat("4. TRANSFORMACIÃ“N:\n")
cat("   â€¢ log(price) para normalizar distribuciÃ³n\n")
cat("   â€¢ center + scale para features\n\n")
cat("5. ARQUITECTURA SUGERIDA (para tu Mac):\n")
cat("   â€¢ 3 capas: 35â†’25â†’15 neuronas\n")
cat("   â€¢ RegularizaciÃ³n: decay = 0.01\n")
cat("   â€¢ Early stopping: patience = 20 epochs\n")
cat("   â€¢ MaxNWts = 3000\n\n")
cat("====================================================================\n\n")
# Guardar reporte
sink("data_verification_report.txt")
cat("REPORTE DE VERIFICACIÃ“N DE DATOS\n")
cat(sprintf("Fecha: %s\n\n", Sys.time()))
cat("RESUMEN:\n")
cat(sprintf("  Observaciones train: %s\n", comma(nrow(train))))
cat(sprintf("  Observaciones test:  %s\n", comma(nrow(test))))
cat(sprintf("  Features disponibles: %d\n", length(available_features)))
cat(sprintf("  Features con NAs: %d\n", nrow(na_summary_with_nas)))
cat(sprintf("  Observaciones a eliminar: %d (%.2f%%)\n",
rows_to_remove, (rows_to_remove / nrow(train)) * 100))
cat(sprintf("  Observaciones finales: %s\n\n",
comma(nrow(train) - rows_to_remove)))
cat("PROBLEMAS DETECTADOS:\n")
if (total_problems == 0) {
cat("  Ninguno - datos en perfecto estado\n\n")
} else {
for (i in 1:length(problem_list)) {
cat(sprintf("  %d. %s\n", i, problem_list[i]))
}
cat("\n")
}
cat("TOP 10 FEATURES MÃS CORRELACIONADAS:\n")
for (i in 1:min(10, length(correlations))) {
cat(sprintf("  %d. %-25s: %.4f\n", i, names(correlations)[i], correlations[i]))
}
sink()
cat("ğŸ“„ Reporte guardado: data_verification_report.txt\n\n")
cat("====================================================================\n")
cat("VERIFICACIÃ“N COMPLETADA\n")
cat("====================================================================\n\n")
if (total_problems == 0) {
cat("âœ… TODO OK - LISTO PARA ENTRENAMIENTO NOCTURNO\n\n")
} else {
cat("âš ï¸  REVISAR PROBLEMAS ANTES DE CONTINUAR\n\n")
}
source("~/Downloads/verify_data_complete.R")
rm(list = ls())
gc()
set.seed(2025)
cat("â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—\n")
cat("â•‘                                                                  â•‘\n")
cat("â•‘           RED NEURONAL PROFUNDA - ARQUITECTURA MÃXIMA           â•‘\n")
cat("â•‘                                                                  â•‘\n")
cat("â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n\n")
cat("1. CONFIGURACIÃ“N INICIAL\n")
cat("====================================================================\n")
# Verificar sistema
cat(sprintf("Sistema detectado:\n"))
cat(sprintf("  OS: %s\n", Sys.info()["sysname"]))
cat(sprintf("  Procesador: %s\n", Sys.info()["machine"]))
cat(sprintf("  Cores disponibles: %d\n", parallel::detectCores()))
# Configurar paralelizaciÃ³n (usar 3 de 4 cores)
n_cores <- min(3, parallel::detectCores() - 1)
cat(sprintf("  Cores a usar: %d (dejar 1 libre)\n\n", n_cores))
# Instalar/cargar librerÃ­as
cat("Cargando librerÃ­as...\n")
packages <- c("tidyverse", "neuralnet", "caret", "scales", "doParallel")
for (pkg in packages) {
if (!require(pkg, character.only = TRUE, quietly = TRUE)) {
cat(sprintf("  Instalando %s...\n", pkg))
install.packages(pkg, dependencies = TRUE)
}
}
suppressPackageStartupMessages({
library(tidyverse)
library(neuralnet)
library(caret)
library(scales)
library(doParallel)
})
cat("âœ“ LibrerÃ­as cargadas\n\n")
# Configurar paralelizaciÃ³n
registerDoParallel(cores = n_cores)
cat("2. CARGANDO DATOS\n")
cat("--------------------------------------------------------------------\n")
train <- read_csv("stores/train_final.csv", show_col_types = FALSE)
test <- read_csv("stores/test_final.csv", show_col_types = FALSE)
cat(sprintf("âœ“ Train: %s Ã— %d\n", comma(nrow(train)), ncol(train)))
cat(sprintf("âœ“ Test:  %s Ã— %d\n\n", comma(nrow(test)), ncol(test)))
cat("2. SELECCIONANDO FEATURES NUMÃ‰RICAS\n")
cat("--------------------------------------------------------------------\n")
# SOLO FEATURES NUMÃ‰RICAS (eliminar categÃ³ricas)
features <- c(
# BÃ¡sicas (4)
'area', 'habitaciones', 'banios', 'n_parqueaderos',
# SocioeconÃ³micas (4) - IMPORTANTES
'EPE', 'EPT', 'EPCC', 'recaudo_predial',
# Distancias (4)
'distnearestlibrary', 'distnearestschool',
'distnearestmuseum', 'distnearesttransmi',
# Amenidades interiores (12)
'cocina_americana', 'cocina_integral', 'balcon', 'terraza',
'chimenea', 'walking_closet', 'duplex', 'deposito',
'altillo', 'piso_madera', 'piso_porcelanato', 'remodelado',
# Amenidades edificio (10)
'gimnasio', 'piscina', 'sauna', 'jacuzzi',
'ascensor', 'zona_verde', 'bbq', 'conjunto_residencial',
'vigilancia_24h', 'porteria',
# Amenidades adicionales (6)
'cctv', 'parqueadero_cubierto', 'parqueadero_comunal',
'zona_infantil', 'salon_comunal', 'terraza_comunal',
# Otras (2)
'pet_friendly', 'zona_humeda',
# UbicaciÃ³n (2) - NUMÃ‰RICAS
'lat', 'lon',
# Temporal (2)
'month', 'year'
)
# Verificar features disponibles
available_features <- features[features %in% names(train)]
cat(sprintf("âœ“ Features disponibles: %d\n\n", length(available_features)))
cat("3. PREPARANDO DATOS\n")
cat("--------------------------------------------------------------------\n")
# Eliminar columna ...1 si existe
train <- train %>% dplyr::select(-matches("^\\.\\.\\.[0-9]+"))
test <- test %>% dplyr::select(-matches("^\\.\\.\\.[0-9]+"))
# Crear datasets limpios
train_clean <- train %>%
filter(!is.na(price), price > 0) %>%
mutate(log_price = log(price)) %>%
dplyr::select(property_id, log_price, all_of(available_features))
test_clean <- test %>%
dplyr::select(property_id, all_of(available_features))
cat(sprintf("âœ“ Train limpio: %s observaciones\n", comma(nrow(train_clean))))
cat(sprintf("âœ“ Features: %d\n", length(available_features)))
# Imputar NAs con mediana/0
for (feat in available_features) {
# Train
if (all(train_clean[[feat]] %in% c(0, 1, NA), na.rm = TRUE)) {
# Binaria - usar 0
train_clean[[feat]][is.na(train_clean[[feat]])] <- 0
test_clean[[feat]][is.na(test_clean[[feat]])] <- 0
} else {
# NumÃ©rica - usar mediana
med_val <- median(train_clean[[feat]], na.rm = TRUE)
if (is.na(med_val)) med_val <- 0
train_clean[[feat]][is.na(train_clean[[feat]])] <- med_val
test_clean[[feat]][is.na(test_clean[[feat]])] <- med_val
}
}
cat("âœ“ NAs imputados\n\n")
cat("4. FEATURE ENGINEERING\n")
cat("--------------------------------------------------------------------\n")
add_features <- function(data) {
data %>%
mutate(
area_per_room = area / pmax(habitaciones, 1),
luxury_index = (piscina + gimnasio + sauna + jacuzzi) / 4,
security_index = (vigilancia_24h + porteria + cctv) / 3,
socioeconomic_avg = (EPE + EPT + EPCC) / 3
)
}
train_clean <- add_features(train_clean)
test_clean <- add_features(test_clean)
new_features <- c('area_per_room', 'luxury_index', 'security_index', 'socioeconomic_avg')
all_features <- c(available_features, new_features)
cat(sprintf("âœ“ +%d features derivadas\n", length(new_features)))
cat(sprintf("  TOTAL: %d features\n\n", length(all_features)))
cat("5. NORMALIZANDO\n")
cat("--------------------------------------------------------------------\n")
preprocess_params <- preProcess(
train_clean %>% dplyr::select(all_of(all_features)),
method = c("center", "scale")
)
train_scaled_features <- predict(preprocess_params,
train_clean %>% dplyr::select(all_of(all_features)))
test_scaled_features <- predict(preprocess_params,
test_clean %>% dplyr::select(all_of(all_features)))
train_scaled <- bind_cols(
train_clean %>% dplyr::select(property_id, log_price),
train_scaled_features
)
test_scaled <- bind_cols(
test_clean %>% dplyr::select(property_id),
test_scaled_features
)
cat("âœ“ NormalizaciÃ³n completa\n\n")
cat("6. TRAIN/VAL SPLIT (80/20)\n")
cat("--------------------------------------------------------------------\n")
set.seed(123)
train_index <- createDataPartition(train_scaled$log_price, p = 0.8, list = FALSE)
train_set <- train_scaled[train_index, ]
val_set <- train_scaled[-train_index, ]
cat(sprintf("âœ“ Train: %s\n", comma(nrow(train_set))))
cat(sprintf("âœ“ Val:   %s\n\n", comma(nrow(val_set))))
cat("5. DISEÃ‘ANDO ARQUITECTURA DE RED PROFUNDA\n")
cat("====================================================================\n\n")
cat("ARQUITECTURA Ã“PTIMA PARA TU HARDWARE:\n")
cat("--------------------------------------------------------------------\n")
cat("\n")
cat("  INPUT LAYER (Features)    HIDDEN LAYERS            OUTPUT\n")
cat("  ----------------------    -------------            ------\n")
cat("\n")
cat(sprintf("      [%2d features]   â†’   [30 neuronas]   â†’\n", length(available_features)))
cat("                                 â†“ (relu)\n")
cat("                             [20 neuronas]   â†’\n")
cat("                                 â†“ (relu)\n")
cat("                             [10 neuronas]   â†’  [log_price]\n")
cat("\n")
cat("  Total de pesos: ~", (length(available_features)*30 + 30*20 + 20*10 + 10), "\n")
cat("\n")
cat("--------------------------------------------------------------------\n")
cat("CARACTERÃSTICAS:\n")
cat("  â€¢ 3 capas ocultas (30 â†’ 20 â†’ 10)\n")
cat("  â€¢ ActivaciÃ³n: ReLU (mejor que sigmoid para redes profundas)\n")
cat("  â€¢ RegularizaciÃ³n: Error threshold para early stopping\n")
cat("  â€¢ Algoritmo: Resilient backpropagation (rprop+)\n")
cat("  â€¢ Aprox. ", (length(available_features)*30 + 30*20 + 20*10 + 10), " pesos a entrenar\n")
cat("\n")
cat("ESTIMACIÃ“N DE TIEMPO:\n")
cat("  â€¢ Con tus specs: 60-120 minutos\n")
cat("  â€¢ Depende de convergencia\n")
cat("  â€¢ 4 cores Intel i5 @ 2.4GHz\n")
cat("  â€¢ 8GB RAM (suficiente)\n\n")
# Confirmar antes de entrenar
cat("âš ï¸  ADVERTENCIA: Este entrenamiento tomarÃ¡ 1-2 horas.\n")
rm(list = ls())
gc()
set.seed(2025)
cat("â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—\n")
cat("â•‘                                                                  â•‘\n")
cat("â•‘           RED NEURONAL PROFUNDA - ARQUITECTURA MÃXIMA           â•‘\n")
cat("â•‘                                                                  â•‘\n")
cat("â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n\n")
cat("1. CONFIGURACIÃ“N INICIAL\n")
cat("====================================================================\n")
# Verificar sistema
cat(sprintf("Sistema detectado:\n"))
cat(sprintf("  OS: %s\n", Sys.info()["sysname"]))
cat(sprintf("  Procesador: %s\n", Sys.info()["machine"]))
cat(sprintf("  Cores disponibles: %d\n", parallel::detectCores()))
# Configurar paralelizaciÃ³n (usar 3 de 4 cores)
n_cores <- min(3, parallel::detectCores() - 1)
cat(sprintf("  Cores a usar: %d (dejar 1 libre)\n\n", n_cores))
# Instalar/cargar librerÃ­as
cat("Cargando librerÃ­as...\n")
packages <- c("tidyverse", "neuralnet", "caret", "scales", "doParallel")
for (pkg in packages) {
if (!require(pkg, character.only = TRUE, quietly = TRUE)) {
cat(sprintf("  Instalando %s...\n", pkg))
install.packages(pkg, dependencies = TRUE)
}
}
suppressPackageStartupMessages({
library(tidyverse)
library(neuralnet)
library(caret)
library(scales)
library(doParallel)
})
cat("âœ“ LibrerÃ­as cargadas\n\n")
# Configurar paralelizaciÃ³n
registerDoParallel(cores = n_cores)
train <- read_csv("stores/train_final.csv", show_col_types = FALSE)
test <- read_csv("stores/test_final.csv", show_col_types = FALSE)
cat(sprintf("âœ“ Train: %s Ã— %d\n", comma(nrow(train)), ncol(train)))
cat(sprintf("âœ“ Test:  %s Ã— %d\n\n", comma(nrow(test)), ncol(test)))
cat("2. SELECCIONANDO FEATURES NUMÃ‰RICAS\n")
cat("--------------------------------------------------------------------\n")
# SOLO FEATURES NUMÃ‰RICAS (eliminar categÃ³ricas)
features <- c(
# BÃ¡sicas (4)
'area', 'habitaciones', 'banios', 'n_parqueaderos',
# SocioeconÃ³micas (4) - IMPORTANTES
'EPE', 'EPT', 'EPCC', 'recaudo_predial',
# Distancias (4)
'distnearestlibrary', 'distnearestschool',
'distnearestmuseum', 'distnearesttransmi',
# Amenidades interiores (12)
'cocina_americana', 'cocina_integral', 'balcon', 'terraza',
'chimenea', 'walking_closet', 'duplex', 'deposito',
'altillo', 'piso_madera', 'piso_porcelanato', 'remodelado',
# Amenidades edificio (10)
'gimnasio', 'piscina', 'sauna', 'jacuzzi',
'ascensor', 'zona_verde', 'bbq', 'conjunto_residencial',
'vigilancia_24h', 'porteria',
# Amenidades adicionales (6)
'cctv', 'parqueadero_cubierto', 'parqueadero_comunal',
'zona_infantil', 'salon_comunal', 'terraza_comunal',
# Otras (2)
'pet_friendly', 'zona_humeda',
# UbicaciÃ³n (2) - NUMÃ‰RICAS
'lat', 'lon',
# Temporal (2)
'month', 'year'
)
# Verificar features disponibles
available_features <- features[features %in% names(train)]
cat(sprintf("âœ“ Features disponibles: %d\n\n", length(available_features)))
cat("3. PREPARANDO DATOS\n")
cat("--------------------------------------------------------------------\n")
# Eliminar columna ...1 si existe
train <- train %>% dplyr::select(-matches("^\\.\\.\\.[0-9]+"))
test <- test %>% dplyr::select(-matches("^\\.\\.\\.[0-9]+"))
# Crear datasets limpios
train_clean <- train %>%
filter(!is.na(price), price > 0) %>%
mutate(log_price = log(price)) %>%
dplyr::select(property_id, log_price, all_of(available_features))
test_clean <- test %>%
dplyr::select(property_id, all_of(available_features))
cat(sprintf("âœ“ Train limpio: %s observaciones\n", comma(nrow(train_clean))))
cat(sprintf("âœ“ Features: %d\n", length(available_features)))
# Imputar NAs con mediana/0
for (feat in available_features) {
# Train
if (all(train_clean[[feat]] %in% c(0, 1, NA), na.rm = TRUE)) {
# Binaria - usar 0
train_clean[[feat]][is.na(train_clean[[feat]])] <- 0
test_clean[[feat]][is.na(test_clean[[feat]])] <- 0
} else {
# NumÃ©rica - usar mediana
med_val <- median(train_clean[[feat]], na.rm = TRUE)
if (is.na(med_val)) med_val <- 0
train_clean[[feat]][is.na(train_clean[[feat]])] <- med_val
test_clean[[feat]][is.na(test_clean[[feat]])] <- med_val
}
}
cat("âœ“ NAs imputados\n\n")
cat("4. FEATURE ENGINEERING\n")
cat("--------------------------------------------------------------------\n")
add_features <- function(data) {
data %>%
mutate(
area_per_room = area / pmax(habitaciones, 1),
luxury_index = (piscina + gimnasio + sauna + jacuzzi) / 4,
security_index = (vigilancia_24h + porteria + cctv) / 3,
socioeconomic_avg = (EPE + EPT + EPCC) / 3
)
}
train_clean <- add_features(train_clean)
test_clean <- add_features(test_clean)
new_features <- c('area_per_room', 'luxury_index', 'security_index', 'socioeconomic_avg')
all_features <- c(available_features, new_features)
cat(sprintf("âœ“ +%d features derivadas\n", length(new_features)))
cat(sprintf("  TOTAL: %d features\n\n", length(all_features)))
cat("5. NORMALIZANDO\n")
cat("--------------------------------------------------------------------\n")
preprocess_params <- preProcess(
train_clean %>% dplyr::select(all_of(all_features)),
method = c("center", "scale")
)
train_scaled_features <- predict(preprocess_params,
train_clean %>% dplyr::select(all_of(all_features)))
test_scaled_features <- predict(preprocess_params,
test_clean %>% dplyr::select(all_of(all_features)))
train_scaled <- bind_cols(
train_clean %>% dplyr::select(property_id, log_price),
train_scaled_features
)
test_scaled <- bind_cols(
test_clean %>% dplyr::select(property_id),
test_scaled_features
)
cat("âœ“ NormalizaciÃ³n completa\n\n")
cat("6. TRAIN/VAL SPLIT (80/20)\n")
cat("--------------------------------------------------------------------\n")
set.seed(2025)
train_index <- createDataPartition(train_scaled$log_price, p = 0.8, list = FALSE)
train_set <- train_scaled[train_index, ]
val_set <- train_scaled[-train_index, ]
cat(sprintf("âœ“ Train: %s\n", comma(nrow(train_set))))
cat(sprintf("âœ“ Val:   %s\n\n", comma(nrow(val_set))))
cat("5. DISEÃ‘ANDO ARQUITECTURA DE RED PROFUNDA\n")
cat("====================================================================\n\n")
cat("ARQUITECTURA Ã“PTIMA PARA TU HARDWARE:\n")
cat("--------------------------------------------------------------------\n")
cat("\n")
cat("  INPUT LAYER (Features)    HIDDEN LAYERS            OUTPUT\n")
cat("  ----------------------    -------------            ------\n")
cat("\n")
cat(sprintf("      [%2d features]   â†’   [30 neuronas]   â†’\n", length(available_features)))
cat("                                 â†“ (relu)\n")
cat("                             [20 neuronas]   â†’\n")
cat("                                 â†“ (relu)\n")
cat("                             [10 neuronas]   â†’  [log_price]\n")
cat("\n")
cat("  Total de pesos: ~", (length(available_features)*30 + 30*20 + 20*10 + 10), "\n")
cat("\n")
cat("--------------------------------------------------------------------\n")
cat("CARACTERÃSTICAS:\n")
cat("  â€¢ 3 capas ocultas (30 â†’ 20 â†’ 10)\n")
cat("  â€¢ ActivaciÃ³n: ReLU (mejor que sigmoid para redes profundas)\n")
cat("  â€¢ RegularizaciÃ³n: Error threshold para early stopping\n")
cat("  â€¢ Algoritmo: Resilient backpropagation (rprop+)\n")
cat("  â€¢ Aprox. ", (length(available_features)*30 + 30*20 + 20*10 + 10), " pesos a entrenar\n")
cat("\n")
cat("ESTIMACIÃ“N DE TIEMPO:\n")
cat("  â€¢ Con tus specs: 60-120 minutos\n")
cat("  â€¢ Depende de convergencia\n")
cat("  â€¢ 4 cores Intel i5 @ 2.4GHz\n")
cat("  â€¢ 8GB RAM (suficiente)\n\n")
# Confirmar antes de entrenar
cat("âš ï¸  ADVERTENCIA: Este entrenamiento tomarÃ¡ 1-2 horas.\n")
cat("   AsegÃºrate de:\n")
cat("   â€¢ Conectar cargador\n")
cat("   â€¢ Cerrar otras apps pesadas\n")
cat("   â€¢ No dejar dormir el Mac\n\n")
readline(prompt = "Presiona [Enter] para comenzar el entrenamiento...")
cat("====================================================================\n\n")
# Preparar datos para neuralnet
train_data <- train_set %>%
dplyr::select(all_of(c(available_features, "log_price")))
# Crear fÃ³rmula
formula_nn <- as.formula(paste("log_price ~",
paste(available_features, collapse = " + ")))
cat("Iniciando entrenamiento...\n")
cat(sprintf("Hora de inicio: %s\n\n", Sys.time()))
start_time <- Sys.time()
# ENTRENAR RED NEURONAL PROFUNDA
# hidden = c(30, 20, 10) â†’ 3 capas ocultas
nn_model <- neuralnet(
formula_nn,
data = train_data,
hidden = c(30, 20, 10),      # 3 CAPAS OCULTAS
act.fct = "logistic",         # FunciÃ³n de activaciÃ³n
linear.output = TRUE,         # RegresiÃ³n (no clasificaciÃ³n)
threshold = 0.01,             # Criterio de convergencia
stepmax = 1e6,                # MÃ¡ximo de iteraciones
rep = 1,                      # NÃºmero de repeticiones
algorithm = "rprop+",         # Algoritmo de entrenamiento (mÃ¡s rÃ¡pido)
err.fct = "sse",              # Sum of Squared Errors
likelihood = FALSE            # No calcular likelihood (mÃ¡s rÃ¡pido)
)
source("~/Downloads/neural_network_maximum.R")
